# Compiler

本文主要关于编译器设计和实现。

> [!NOTE]
> 寄存器分配和指令调度其实都是 NP 问题，需要未来深入讨论。

# Lexer & Parser

使用 Flex 和 Bison 实现词法分析和语法分析。

## 配置选项

一些粗略的选项说明。

在 flex 中：
``` flex
/* 可重入

一般这会带来 yyscan_t，用于将当前分析的信息绑定到一个 yyscan_t 对象身上。
*/
%option reentrant

/* 与 bison 配合 */
%option bison-bridge bison-locations

/* 关闭一些没有用的功能

从左到右依次是：
    不使用 yywarp 一般不会使用
    不使用 unistd 可以保证一定的可移植性
    不交互
    不使用默认规则
    不使用预制的 input 函数
    不使用预制的 unput 函数
*/
%option noyywrap nounistd never-interactive nodefault noinput nounput

/* 配置输出文件名 */
%option outfile="lexer.l.cpp" header-file="lexer.l.h"
```

在 bison 中：
``` bison
// 配置输出文件名
%output "parser.y.cpp"
%defines "parser.y.h"

// 可重入
%define api.pure full

// 错误信息
%define parse.error verbose

// 保证位置信息
%locations

// 注入 yyscan_t 参数为 scanner
%lex-param { yyscan_t scanner }
%parse-param { yyscan_t scanner }
```

## 在 flex 文件里使用 yylloc 设定位置

在 flex 的此法文件里，文件位置是使用叫 `yylloc` 的宏实现的，它在不同情况下可能有不同的实现。
但一般情况下，它的类型默认是 `YYLTYPE`，定义会是如下情况：

``` c
typedef struct YYLTYPE YYLTYPE;
struct YYLTYPE
{
  int first_line;
  int first_column;
  int last_line;
  int last_column;
};
```

它可以用于框住一个被词法分析出来的 `token` 所对应的文本。
`first_line` 和 `first_column` 用于标注文本的开始处；
`last_line` 和 `last_column` 用于标注文本的结束处。

如果能够正确设置这四个信息，就可以在错误分析的时候表示出更多有用的信息用于分析问题。

`yylloc` 这个宏在 flex 文件里，可以在词法规则里和 `yylval` 一样直接使用。
例如我经常会在遇到换行的时候做这样的操作：

``` flex
%top{

#define YY_NEWLINE_ACTION do {                    \
  yylloc->first_line += 1;                        \
  yylloc->last_line += 1;                         \
  yylloc->first_column = yylloc->last_column = 1; \
} while (0);

}

newline \r?\n

%%
<COMMENT>{newline}      { YY_NEWLINE_ACTION }
"//".*{newline}         { YY_NEWLINE_ACTION }
{newline}               { YY_NEWLINE_ACTION }
%%

```

这样子，就可以在每次遇上换行的时候对行信息和列信息同时更新。
同样的，如果需要对列信息进行实时更新，我们也需要对 `yylloc` 操作。
不过这个操作在分析到任何词法单元的时候都可能进行，我们一般会使用 `YY_USER_ACTION` 这个宏定义。

`YY_USER_ACTION` 这个宏会在所有的词法规则开始前进行，具体情况可以查看生成后的文件。
一般可以如此定义：

``` flex
%top{

#define YY_USER_ACTION do {                   \
  yylloc->first_column = yylloc->last_column; \
  yylloc->last_column += strlen(yytext);      \
} while (0);

}
```

这样就可以顺利的对列信息进行实时更新。

在完成以上的内容后，`yylloc` 就可以正确生成位置信息，以用于在 bison 文件里的 `yyerror()` 中。

## 比较精准的 yyerror()

在完成 `配置选项` 和 `在 flex 文件里使用 yylloc 设定位置` 章节的内容后，就可以开始编写比较精准的 `yyerror()` 函数了。

首先，在前文的描述中，配置可以生成如下的函数：

``` c
int yyerror(YYLTYPE *yylloc, yyscan_t scanner, const char *msg);
```

它接受三个参数，其中第三个参数就是自动生成的错误信息。
第一个参数是我们用于定位的 `yylloc`，之前章节里有讲述如何让它记录正确信息。
第二个参数是我们用于分析的 `scanner`，它有很多可以使用的接口。

这里，我们主要期望打印如下格式的报错信息：

```
{文件名}:{行}:{列}: {报错信息}
```

其中，后面三者已经可以做到了，只有文件名难以获取。
实际上，`yyscan_t` 提供了一个预留的位置给用户 `yyextra`。
这个位置是一个用户可自定的通用指针值，你可以选择将一个指向保存了上下文信息的结构体传给他。
比如在 `yyparse()` 开始前，进行 `yyset_extra()`，然后在 `yyerror()` 中通过 `yyget_extra()` 函数和 `scanner` 获取到上下文的信息。

一个简单的实现就是将文件名对应的指针传递给 `yyextra`，然后在 `yyerror()` 里获取出来，就像：

```c
int yyerror(YYLTYPE *yylloc, yyscan_t scanner, const char *msg) {
  fprintf(stderr, "%s:%d:%d: %s\n"
                  (const char *)yyget_extra(scanner),
                  yylloc->first_line, yylloc->first_column, msg);
  return 0;
}
```

这样就可以打印出基本完整的报错信息了。
这对未来的调试分析会有很大的帮助。

## 使用 yyparse()

一个可重入的，通过读取文件作为输入的 `yyparse()` 可以如此编写：

``` c
#include "lexer.l.h"
#include "parser.y.h"

int parse_file(const char *file) {
  int code = 0;
  code = yylex_init(&scanner);
  if (code != 0) {
    fprintf(stderr, "scanner initialize failed, code : %d\n", code);
    return code;
  }

  FILE *fp = fopen(file, "r");
  YY_BUFFER_STATE state = yy_create_buffer(fp, YY_BUF_SIZE, scanner);
  yy_switch_to_buffer(state, scanner);

  yyset_extra((void *)file, scanner);
  code = yyparse(scanner);
  if (code != 0)
    return code;

  yy_delete_buffer(state, scanner);
  fclose(fp);

  return yylex_destroy(scanner);
}
```

目前来看，这样子的处理可以保证两个并行的分析之间没有任何依赖。
不过在真实场景下，对于分析出的语法树或者其他中间语言代码来说，它们可能需要被加载到同一个位置进行统一处理。
这个时候就可能有临界区出现，需要对操作做加锁等操作。

# 中间语言

# 寄存器分配

寄存器分配可以使用比较架构无关的方式设计处理，以下是我们的设计思路。

## ABI 信息分离

将寄存器分为几个大类，以下列举比较常用的几类：

1. 整数寄存器
2. 浮点寄存器
3. 向量寄存器

这些类之间一般是没有寄存器冲突问题的，有些技术，例如使用浮点寄存器临时存储溢出的整数寄存器内容，需要处理器在两类寄存器中传递数据开销能够小于内存读取开销。一般来说，我们可以将未进行分配的寄存器分到这几个大类中，由于大类之间没有联系，所以每个大类内寄存器分配是独立进行的。这也意味着算法可以并行执行，以减少时间开销。

接下来，我们将大类内部分配几个小类：

1. 调用者保存寄存器 `Caller Save`
2. 被调用者保存寄存器 `Callee Save`
3. 参数寄存器 `Argument`

其中，参数寄存器一般都是调用者保存寄存器，但由于参数寄存器的特殊性，这里将其也分离出来。

这三个小类，分别对于不同函数有着不同的好处。比如函数内部有着比较多的函数调用操作，就可以将未分配的寄存器多分配给被调用者保存寄存器；相应的函数内部鲜少有函数调用的函数可以更倾向于使用调用者保存的寄存器。这个技巧在 RISC-V 这样的架构中尤为有用，由于其寄存器中多，过多的状态保存会导致开销函数调用巨大，所以减少状态保存开销也是很重要的一个优化。

在这几类中，有的架构还有一组寄存器，一般当作常用寄存器用于压缩指令集。多倾向于在这些寄存器上保存，可以让生成的代码体积减少，对于一些处理器来说，意味着一次可以加载的指令数更多，减少整体的 I$ miss。

函数参数参与寄存器分配与一般寄存器区别不大，只是在函数调用过程中有些不一样的操作需要关注。

如此分类之后，接下来就可以对物理寄存器进行编号，这些编号用于区别所有的寄存器。这些编号未来可以用于着色和查找寄存器信息。

## 活跃性分析

为了能够做到一些比较特殊的操作，我们介绍一种以图着色和线性扫描为基础的混合活跃性分析过程。

首先我们按照活跃分析经典的不动点算法计算出基本块的 live in 和 live out。

对于每一个基本块先做如下操作

1. 将 `live in`，`live out`，`live def`，`live use` 集合清空
2. 如果本块是函数的入口基本块，将函数参数加入 `live def` 中
3. 初始化计算 `live use` 和 `live def` 集合的信息

初始化计算步骤如下：

按顺序历遍基本块内的每一个操作，对于当前操作 op

1. 如果有操作寄存器，且操作寄存器不在 `live def` 集合中，加入 `live use` 集合
2. 如果有结果寄存器，将其加入 `live def` 集合中

当对每个基本块完成上述操作后，做如下不动点算法：

逆序历遍所有基本块以加快传播速度。

对于每一个基本块，做如下计算：

1. 获取所有后继基本块的 `live in` 并加入集合 `live out` 中。
2. 将当前基本块的 `live in` 置为 `live use`。
3. 集合计算 `live out` - `live def`。也即两个集合的差集。
4. 将步骤三结果插入 `live in`。

如果在这个过程中，`live out` 出现了变化，那么当一次逆序历遍完成后还需要再逆序历遍一次，直到没有变化。检查变化的办法可以通过对比 `live out` 集合元素数量的变化。

当以上传播完成后，最后再一次将函数参数设置为函数入口基本块的 `live in` 即计算完成。

## 活跃区间计算

在干涉图构建中，可能需要对每一个操作都计算 `live in` 和 `live out`。而且计算结果不能够重复利用。为了解决这种消耗，我们选择使用线性扫描的办法，先计算虚拟寄存器的活跃区间。

活跃区间计算过程如下：

1. 函数内所有操作都做好标记，也即顺序标号
2. 顺序历遍所有基本块，对于当前基本块：
   1. 给 `live in` 中的虚拟寄存器设置 def 点为第一个操作的位置。
   2. 顺序历遍所有操作，对于当前操作：
      1. 如果有结果寄存器，则给结果寄存器设置 def 点
      2. 如果有操作数寄存器，则给操作数寄存器设置 use 点
   3. 给 `live out` 中的虚拟寄存器设置 use 点为最后一个操作编号 +1
   4. 计算活跃区间

在实现的时候有一个可行的办法：

- 给虚拟寄存器设置 def 点的时候，如果已经设置过 def 点，那么先生成一次活跃区间，然后重新设置 def 点
- 给虚拟寄存器设置 use 点时候，每次都添加进数组中，用于未来使用
- 给虚拟寄存器生成活跃区间的时候，区间为 `[def, use.back())`，也即以 def 点为左边界，最后一次 use 为右边界的左闭右开区间。

完成后可以得到正确的活跃区间结果。

## 各种用于评估的计算和优化分析

在正式开始寄存器分配之前，可以对权重等信息进行一次计算。或者对比如图着色可能需要的 merge 操作，贪心寄存器分配需要的 split 点进行分析。得到这些指导信息后就可以开始正式的寄存器分配了。

## 进行分配

以下我们着重介绍图着色寄存器分配，并提出如何将结合贪心寄存器分配。

图着色寄存器分配需要获得干涉图。而当前我们已经计算出所有寄存器的活跃区间了，所以只要两个寄存器有活跃区间重叠，就可以给两个寄存器之间加一条边。

从活跃区间获取干涉图只需要一个两个优先队列，一个优先队列以区间开始为目标值建立小顶堆，而另一个则以区间结束建立小顶堆。

以这两个优先队列就可以计算出干涉图。此处不加赘述，具体实现可以有各种办法。

获取干涉图后，就可以进行 merge 操作。该操作实现有比较多办法，也可以选择不做。

之后就是选取一种图着色寄存器分配方案进行寄存器分配。我们选择使用乐观 Kempe 图着色法，并且摘掉图中节点后将其放入优先队列里。之后从优先队列里一个个取出恢复原图。

在这个阶段可以做如下优化：

1. 如果经常作为函数参数，则优先分配到指定参数寄存器中
2. 如果不能 spill 则优先进行寄存器分配
3. 如果倾向于某种小类的寄存器，优先从该类进行分配
4. 如果是返回值，优先分配到指定的返回值寄存器中

当然，会有一些节点会因为冲突过多而不能被放进寄存器中。此时，可以做一个贪心寄存器的步骤，也即 split。

split 和 merge 是一对相反的操作，前者将一个节点分裂成两个节点，添加移动操作以减少冲突；后者将一对移动操作的源寄存器和目的寄存器合并为一个节点，并删除移动操作。

由于开发时间紧迫，并没有进行寄存器数据流分析获取信息以结合两个操作，目前保留实现。

完成分配后做了一些操作，最后还是溢出，就需要重写。

剩下内容则和设计者本身选择策略有关了，就不再描述。

# 指令重排

## 提取指令信息

核心信息如下：

1. 需要占据的处理器器件
2. 指令类型
3. 需要的寄存器资源
4. 写入的寄存器资源
5. 是否对内存操作
   1. 内存操作地址
   2. 内存操作宽度

获取这些信息后，就可以进行调度。也即对于各种 ir，如果能抽象出这些信息，就足以开始调度了。

## 设置抽象机器

我们设计如下抽象机器：

1. 拥有各种器件若干，并标记好（器件，序号）对
2. 指令类型的延迟
3. 指令类型的权重计算法则

## 构建有向无环图

使用先前得到的指令信息，绘制出有向无环图。每一个节点都有若干前驱和后继。

## 调度

调度过程如下：

设置当前时间为 t = 0，所有没有前驱的指令组成可发射队列

1. 尝试选取出一条指令，该指令满足：
   - 抽象机器有对应的空闲器件
   - 满足处理器不会 stall 的一些特定条件
   - 优先级较高
2. 如果有一条指令满足要求，则在当前时间 t 发射并加入预约表
   - 预约表项为如下信息：
      - 指令完成时间 t + 指令类型的延迟
      - 指令使用的器件（器件，序号）对
      - 指令本身（用于操作）
   - 预约表以指令完成时间为 key 进行排序，可以设计成优先队列
   - 反射后的指令不再会被选择
3. 如果没有指令满足要求，从预约表里选取一个最早结束的指令，并将时间设置为对应的完成时间 t0
   - 将所有在 t0 时刻及之前完成的指令全部标记为完成状态，并释放对应的器件，删除预约表项
   - 从所有的完成状态的节点的后继中记录的前驱删除完成状态的节点
   - 将没有前驱的节点加入可发射队列
   - 重新进行步骤 1

而选取部分，就是每一个调度器不同之处，可以以不同的评价标准构成不同的指令队列。